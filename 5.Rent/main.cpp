#include <iostream>

using namespace std;
const int N = 1000;
int r[N][N];
int fro[N][N];//从i 到 j 经过的第一个站
int n;
int i,j;
/*

2019年1月19日 00点07分
游艇租赁
    n个站  i到j的站的费用都不一01样 是一个二维表存储的 算到终点的最少租金是多少

    1.思路：
            ******************错误*******************************
        从后往前思考
            两种决策：前一个站点租 还是 不租
                租：c[i][j] = c[i][j-1]+r[j-1][j]
                不租: c[i][j] = c[i][j-2]+r[j-2][j]  错误的
            *******************错误******************************

            额额...这种思考方向有点问题

            可以这样思考，已经计算出从1到j-1的最短费用，这时到到达j，则思考从前面哪一站到j费用最少
            所以dp方程为:
                c[i][j] = min(c[1][x]+c[x][j])  1<=x<j

                最优子结构证明：
                    当前c[i]为最少租金，则c[i-1]也是最优
                        反证法:如果c[i-1]不是最优，则存在一个c<c[i-1]，则c+r[i-1,i]<c[i-1]+r[i-1,i]=c[i]，而当前c[i]是最优，与前提矛盾，所以c[i-1]是最优
                (这里的证明是错误的 但是我会证明啦)

可以说 这是我自己做出来的第一道动态规划题吧！ 哈哈哈 感谢邓老师啊！！！
按邓老师的 思考动态规划问题的思路 更加普适 更加容易思考问题吧(虽然dp方程和书上的一样 但是思考过程是不一样的)

斜着的数组 很不熟练啊！！！（这里可以不用斜着填  可以逐列 从下往上填）

注意！！！ 当dp方程有了之后，数组初始化之后，思考如何填表 编程的时候最方便

注意！！！ 个别例子跑起来是对的 算法不一定正确！！！
*/

void rent(){
    //初始化数组c state 放到main里面去了
    int p,q;
    int x=0;
    int temp;
    for(i=3;i<=n;i++){
        for(j=1;j<=n-i+1;j++){
            p = j;
            q = j+i-1;  // ? 这里沿对角线计算表有点难度(脑子有点转不过来)
            fro[p][q] = p;
            for(x=p+1;x<q;x++){
                temp = r[p][x]+r[x][q];
                if(r[p][q]>temp){
                    r[p][q] = temp;
                    fro[p][q] = x;
                }
            }
        }
    }
}

void print(int r,int s){//这里递归一开始还写错了（把ro的含义搞错了 以为记录的是到达j前一个站） 哈哈....
    cout<<r<<" ";
    if(fro[r][s]==r){
        cout<<s<<endl;
        return;
    }
    print(fro[r][s],s);
}

int main()
{
    cout<<"输入站点个数"<<endl;
    cin>>n;
    cout<<"站点间费用"<<endl;
    for(i=1;i<=n;i++){
        for(j=i+1;j<=n;j++){
            cin >> r[i][j];
        }
    }
    rent();
    cout<<"最少租赁费用为:"<<r[1][n]<<endl;
    cout<<"路线为:";
    print(1,6);
    return 0;
}
